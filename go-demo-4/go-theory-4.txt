// // GO THEORY 4 // //

// POINTER
// EXERCISE ARRAY'S REVERSE
// STRUCT
// POINTERS IN STRUCT
// RUNE
// EXERCISE PASSWORD GENERATION
//
//


// 
// // POINTER
// 

// Указатели - это переменные, которые хранят АДРЕС В ПАМЯТИ, а не адрес значения.
num := 10
numPointer := &num

// Использование указателей:
// 1. Убирает лишнее копирование
// 2. Мутирует значение

// Чтобы из адреса в памяти получить обратно значение нужно использовать символ *


///////
package main

import "fmt"

func main() {
	a := 5
	pointerA := &a
	res := double(a)
	fmt.Println(*pointerA)
	// переменная как значение со знаком * logs: 5
	// переменная как адрес в памяти logs: 0xc000104020

	fmt.Println(res)
}

func double(num int) int {
	return num * 2
}
///////


// 
// // EXERCISE ARRAY'S REVERSE
// 

///////
package main

import "fmt"

func main() {
	a := [4]int{1, 2, 3, 4}
	reverse(&a)
	fmt.Println(a)
}

func reverse(arr *[4]int) {
	for index, value := range *arr {
		(*arr)[len(arr) - 1 - index] = value
	}
}
///////


// 
// // STRUCT
//

// type name struct {
	fieldName: type,
	fieldName: type,
	fieldName: type,
}

///////
package main

import "fmt"

type account struct {
	login string
	password string
	url string
}

func main() {
	login := promptData("Введите логин")
	password := promptData("Введите пароль")
	url := promptData("Введите URL")

	// account1 := account{
	// 	login,
	// 	password,
	// 	url,
	// }
	account1 := account{
		login: login,
		password: password,
		url: url,
	}

	outputPassword(login, password, url)
}

func promptData(prompt string) string {
	fmt.Print(prompt)
	var result string
	fmt.Scan(&result)
	return result
}

func outputPassword(login, password, url string) {
	fmt.Println(login, password, url)
}
///////


// 
// // POINTERS IN STRUCT
// 

///////
package main

import "fmt"

type account struct {
	login string
	password string
	url string
}

func main() {
	login := promptData("Введите логин: ")
	password := promptData("Введите пароль: ")
	url := promptData("Введите URL: ")

	myAccount := account{
		login: login,
		password: password,
		url: url,
	}

	outputPassword(myAccount)
}

func promptData(prompt string) string {
	fmt.Print(prompt)
	var result string
	fmt.Scan(&result)
	return result
}

// Функция получает acc - копию account
func outputPassword(acc account) {
	fmt.Println(acc)
	fmt.Println(acc.login, acc.password, acc.url)
}
///////


// 
// // RUNE
//

// Rune - тип данных символов.
// Rune - удобный alias к int32 для того, чтобы обозначить что это будет буква.
// На самом деле это unicode представление буквы.

str := "Привет!)"
for _, char := range str {
	fmt.Println(char, string(char))
}
// logs: 
// 1055 П
// 1088 р
// 1080 и
// 1074 в
// 1077 е
// 1090 т
// 33 !
// 41 )

// А теперь в виде массива rune:
// variableName := []rune(string)
// ИЛИ
// variableName := []int32(string)
str := []rune("Привет!)")
for _, char := range string(str) {
	fmt.Println(char, string(char))
}
// logs: 
// 1055 П
// 1088 р
// 1080 и
// 1074 в
// 1077 е
// 1090 т
// 33 !
// 41 )


// 
// // EXERCISE PASSWORD GENERATION
// 

// Для работы со случайными числами, 
// импортируем пакет "math/rand/v2"

///////
package main

import (
	"fmt"
	"math/rand/v2"
)

type account struct {
	login string
	password string
	url string
}

var letterRunes = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-_!?*")

func main() {
	fmt.Println(generatePassword(12))

	login := promptData("Введите логин: ")
	password := promptData("Введите пароль: ")
	url := promptData("Введите URL: ")

	myAccount := account{
		login: login,
		password: password,
		url: url,
	}

	outputPassword(&myAccount)
}

func promptData(prompt string) string {
	fmt.Print(prompt)
	var result string
	fmt.Scan(&result)
	return result
}

func outputPassword(acc *account) {
	fmt.Println(acc)
	fmt.Println((*acc).login, acc.password, acc.url)
}

func generatePassword(n int) string {
	result := make([]rune, n)
	for i := range result {
		result[i] = letterRunes[rand.IntN(len(letterRunes))]
	}
	return string(result)
}
///////