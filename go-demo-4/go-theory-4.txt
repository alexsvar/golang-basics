// // GO THEORY 4 // //

// POINTER
// EXERCISE ARRAY'S REVERSE
// STRUCT
// POINTERS IN STRUCT
// RUNE
// EXERCISE PASSWORD GENERATION
// STRUCT METHODS
// EXERCISE STRUCT MUTATION
// FUNCTION-CONSTRUCTOR STRUCT
// STRUCT DATA VALIDATION
// STRUCT GENERATION TRANSFER
// STRUCT COMPOSITION
// SPLITTING THE CODE INTO PACKAGES
// ADDING PACKAGES
// IMPORTS & EXPORTS OF PACKAGES
// ADDING THIRD-PARTY PACKAGES
// WRITE IN TO FILE
// STACK FRAME
// DEFER
// READ FROM FILE
// JSON
// STRUCT TAGS
// SAVING JSON
// SLICE STRUCT
// 
// 


// 
// // POINTER
// 

// Указатели - это переменные, которые хранят АДРЕС В ПАМЯТИ, а не адрес значения.
num := 10
numPointer := &num

// Использование указателей:
// 1. Убирает лишнее копирование
// 2. Мутирует значение

// Чтобы из адреса в памяти получить обратно значение нужно использовать символ *


///////
package main

import "fmt"

func main() {
	a := 5
	pointerA := &a
	res := double(a)
	fmt.Println(*pointerA)
	// переменная как значение со знаком * logs: 5
	// переменная как адрес в памяти logs: 0xc000104020

	fmt.Println(res)
}

func double(num int) int {
	return num * 2
}
///////


// 
// // EXERCISE ARRAY'S REVERSE
// 

///////
package main

import "fmt"

func main() {
	a := [4]int{1, 2, 3, 4}
	reverse(&a)
	fmt.Println(a)
}

func reverse(arr *[4]int) {
	for index, value := range *arr {
		(*arr)[len(arr) - 1 - index] = value
	}
}
///////


// 
// // STRUCT
//

// type name struct {
	fieldName: type,
	fieldName: type,
	fieldName: type,
}

///////
package main

import "fmt"

type account struct {
	login string
	password string
	url string
}

func main() {
	login := promptData("Введите логин")
	password := promptData("Введите пароль")
	url := promptData("Введите URL")

	// account1 := account{
	// 	login,
	// 	password,
	// 	url,
	// }
	account1 := account{
		login: login,
		password: password,
		url: url,
	}

	outputPassword(login, password, url)
}

func promptData(prompt string) string {
	fmt.Print(prompt)
	var result string
	fmt.Scan(&result)
	return result
}

func outputPassword(login, password, url string) {
	fmt.Println(login, password, url)
}
///////


// 
// // POINTERS IN STRUCT
// 

///////
package main

import "fmt"

type account struct {
	login string
	password string
	url string
}

func main() {
	login := promptData("Введите логин: ")
	password := promptData("Введите пароль: ")
	url := promptData("Введите URL: ")

	myAccount := account{
		login: login,
		password: password,
		url: url,
	}

	outputPassword(myAccount)
}

func promptData(prompt string) string {
	fmt.Print(prompt)
	var result string
	fmt.Scan(&result)
	return result
}

// Функция получает acc - копию account
func outputPassword(acc account) {
	fmt.Println(acc)
	fmt.Println(acc.login, acc.password, acc.url)
}
///////


// 
// // RUNE
//

// Rune - тип данных символов.
// Rune - удобный alias к int32 для того, чтобы обозначить что это будет буква.
// На самом деле это unicode представление буквы.

str := "Привет!)"
for _, char := range str {
	fmt.Println(char, string(char))
}
// logs: 
// 1055 П
// 1088 р
// 1080 и
// 1074 в
// 1077 е
// 1090 т
// 33 !
// 41 )

// А теперь в виде массива rune:
// variableName := []rune(string)
// ИЛИ
// variableName := []int32(string)
str := []rune("Привет!)")
for _, char := range string(str) {
	fmt.Println(char, string(char))
}
// logs: 
// 1055 П
// 1088 р
// 1080 и
// 1074 в
// 1077 е
// 1090 т
// 33 !
// 41 )


// 
// // EXERCISE PASSWORD GENERATION
// 

// Для работы со случайными числами, 
// импортируем пакет "math/rand/v2"

///////
package main

import (
	"fmt"
	"math/rand/v2"
)

type account struct {
	login string
	password string
	url string
}

var letterRunes = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-_!?*")

func main() {
	fmt.Println(generatePassword(12))

	login := promptData("Введите логин: ")
	password := promptData("Введите пароль: ")
	url := promptData("Введите URL: ")

	myAccount := account{
		login: login,
		password: password,
		url: url,
	}

	outputPassword(&myAccount)
}

func promptData(prompt string) string {
	fmt.Print(prompt)
	var result string
	fmt.Scan(&result)
	return result
}

func outputPassword(acc *account) {
	fmt.Println(acc)
	fmt.Println((*acc).login, acc.password, acc.url)
}

func generatePassword(n int) string {
	result := make([]rune, n)
	for i := range result {
		result[i] = letterRunes[rand.IntN(len(letterRunes))]
	}
	return string(result)
}
///////


// 
// // STRUCT METHODS
//

// Методы хранят вне класса, рядом со структурами.
// Для того, чтобы указать метод, нужно между func и названием
// указать в скобках название структуры:

type account struct {
	login string
	password string
	url string
}

func (account) outputPassword(acc *account) {
	fmt.Println(acc)
	fmt.Println((*acc).login, acc.password, acc.url)
}

// Рядом с объявлением структуры можно объявить входящий аргумент:
func (acc account) outputPassword() {
	fmt.Println(acc)
	fmt.Println((*acc).login, acc.password, acc.url)
}


// 
// // EXERCISE STRUCT MUTATION
// 

///////
package main

import (
	"fmt"
	"math/rand/v2"
)

type account struct {
	login string
	password string
	url string
}

func (acc *account) outputPassword() {
	fmt.Println(acc)
	fmt.Println(acc.login, acc.password, acc.url)
}

func (acc *account) generatePassword(n int) {
	result := make([]rune, n)
	for i := range result {
		result[i] = letterRunes[rand.IntN(len(letterRunes))]
	}
	acc.password = string(result)
}

var letterRunes = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-_!?*")

func main() {


	login := promptData("Введите логин: ")
	// password := promptData("Введите пароль: ")
	url := promptData("Введите URL: ")

	myAccount := account{
		login: login,
		url: url,
	}

	myAccount.generatePassword(12)
	myAccount.outputPassword()
	fmt.Println(myAccount)
}

func promptData(prompt string) string {
	fmt.Print(prompt)
	var result string
	fmt.Scan(&result)
	return result
}
///////


// 
// // FUNCTION-CONSTRUCTOR STRUCT
// 

// Объявление функции-конструктора
func newAccount() {}
// new в названии - условность, указывающая на функцию-конструктор.

// функция-конструктор принимает 3 аргумента и возвращает struc account
func newAccount(login, password, url string) *account {
	return &account{
		login: login,
		password: password,
		url: url,
	}
}

// Чтобы избежать дополнительного копирования, мы будем возвращать 
// указатель на аккаунт, который мы будем создавать.


// 
// // STRUCT DATA VALIDATION
//

///////
package main

import (
	"errors"
	"fmt"
	"math/rand/v2"
	"net/url"
)

type account struct {
	login string
	password string
	url string
}

func (acc *account) outputPassword() {
	fmt.Println(acc)
	fmt.Println(acc.login, acc.password, acc.url)
}

func (acc *account) generatePassword(n int) {
	result := make([]rune, n)
	for i := range result {
		result[i] = letterRunes[rand.IntN(len(letterRunes))]
	}
	acc.password = string(result)
}

func newAccount(login, password, urlString string) (*account, error) {
	// Validation
	_, err := url.ParseRequestURI(urlString)
	if err != nil {
		return nil, errors.New("INVALID_URL")
	}

	return &account{
		login: login,
		password: password,
		url: urlString,
	}, nil
}

var letterRunes = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-_!?*")

func main() {
	login := promptData("Введите логин: ")
	password := promptData("Введите пароль: ")
	url := promptData("Введите URL: ")

	myAccount, err := newAccount(login, password, url)
	if err != nil {
		fmt.Println("Неверный формат URL")
		return
	}
	myAccount.generatePassword(12)
	myAccount.outputPassword()
	fmt.Println(myAccount)
}

func promptData(prompt string) string {
	fmt.Print(prompt)
	var result string
	fmt.Scan(&result)
	return result
}
///////


// 
// // STRUCT GENERATION TRANSFER
//

///////
package main

import (
	"errors"
	"fmt"
	"math/rand/v2"
	"net/url"
)

type account struct {
	login string
	password string
	url string
}

func (acc *account) outputPassword() {
	fmt.Println(acc)
	fmt.Println(acc.login, acc.password, acc.url)
}

func (acc *account) generatePassword(n int) {
	result := make([]rune, n)
	for i := range result {
		result[i] = letterRunes[rand.IntN(len(letterRunes))]
	}
	acc.password = string(result)
}

// 1. !login -> error
// 2. !password -> generatePassword()
func newAccount(login, password, urlString string) (*account, error) {
	if login == "" {
		return nil, errors.New("INVALID_LOGIN")
	}
	// Validation
	_, err := url.ParseRequestURI(urlString)
	if err != nil {
		return nil, errors.New("INVALID_URL")
	}

	newAcc := &account{
		login: login,
		password: password,
		url: urlString,
	}
	if password == "" {
		newAcc.generatePassword(12)
	}
	return newAcc, nil
}

var letterRunes = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-_!?*")

func main() {
	login := promptData("Введите логин: ")
	password := promptData("Введите пароль: ")
	url := promptData("Введите URL: ")

	myAccount, err := newAccount(login, password, url)
	if err != nil {
		fmt.Println("Неверный формат URL или Login")
		return
	}

	myAccount.outputPassword()
	fmt.Println(myAccount)
}

func promptData(prompt string) string {
	fmt.Print(prompt)
	var result string
	fmt.Scanln(&result)
	return result
}
///////


// 
// // STRUCT COMPOSITION
// 

///////
package main

import (
	"errors"
	"fmt"
	"math/rand/v2"
	"net/url"
	"time"
)

type account struct {
	login string
	password string
	url string
}

type accountWithTimestamp struct{
	createdAt time.Time
	updatedAt time.Time
	acc account
}

func (acc *account) outputPassword() {
	fmt.Println(acc)
	fmt.Println(acc.login, acc.password, acc.url)
}

func (acc *account) generatePassword(n int) {
	result := make([]rune, n)
	for i := range result {
		result[i] = letterRunes[rand.IntN(len(letterRunes))]
	}
	acc.password = string(result)
}

func newAccountWithTimestamp(login, password, urlString string) (*accountWithTimestamp, error) {
	if login == "" {
		return nil, errors.New("INVALID_LOGIN")
	}
	// Validation
	_, err := url.ParseRequestURI(urlString)
	if err != nil {
		return nil, errors.New("INVALID_URL")
	}

	newAcc := &accountWithTimestamp{
		createdAt: time.Now(),
		updatedAt: time.Now(),
		acc: account{
			login: login,
			password: password,
			url: urlString,
		},
	}
	if password == "" {
		newAcc.acc.generatePassword(12)
	}
	return newAcc, nil
}

var letterRunes = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-_!?*")

func main() {
	login := promptData("Введите логин: ")
	password := promptData("Введите пароль: ")
	url := promptData("Введите URL: ")

	myAccount, err := newAccountWithTimestamp(login, password, url)
	if err != nil {
		fmt.Println("Неверный формат URL или Login")
		return
	}

	myAccount.acc.outputPassword()
	fmt.Println(myAccount)
}

func promptData(prompt string) string {
	fmt.Print(prompt)
	var result string
	fmt.Scanln(&result)
	return result
}
///////


// 
// // SPLITTING THE CODE INTO PACKAGES
// 

// Когда код разделён на несколько пакетов, чтобы запустить проект,
// в консоли запускаем команду:
> go run .


// 
// // ADDING PACKAGES
// 

// Как разделять на пакеты?
// 1. По использованию
// 2. По доменной / предметной области
// 3. По бизнес задачам


// 
// // IMPORTS & EXPORTS OF PACKAGES
// 

// 1. Импорты пакетов делаются так же как импорт стандартной библиотеки fmt:
// // import "fmt"
// 2. В импорте пакета нужно прописать полный путь - название модуля + название пакета:
// // import "demo/app-4/account"
// 3. При использовании значений импортируемых пакетов, перед ними нужно поставить 
// название пакета с точкой:
// // account.newAccountWithTimestamp()...
// 4. Чтобы всё работало, экспортировать значения из импортируемого пакета нужно 
// с большой буквы. Есть негласное правило - соглашение:
// // // ВСЁ, ЧТО НАПИСАНО С БОЛЬШОЙ БУКВЫ - СЧИТАЕТСЯ ЭКСПОРТИРУЕМЫМ, 
// // // А ВСЁ, ЧТО НАПИСАНО С МАЛЕНЬКОЙ БУКВЫ - НЕТ.
// Это инкапсуляция: всё что не должно быть доступно снаружи модуля, мы пишем с маленькой буквы, 
// а всё что должно быть доступно - с большой буквы.
// // func newAccountWithTimestamp(...)


// 
// // ADDING THIRD-PARTY PACKAGES
// 

> go get github.com/fatih/color

// в go.mod добавятся все необходимые зависимоси, которые будут использоваться
// для этого пакета. 
// Чтобы восстановить установленные пакеты на другом компьютере,
// мы должны ввести в консоли команду:
> go get 

// Чтобы использовать установленный пакет, в пакете account.go в импортах прописываем
// "github.com/fatih/color", в func OutputPassword вместо fmt.Println(...) 
// пишем color.Cyan(acc.login)


// 
// // GO MOD TIDY
// 

> go mod tidy
// Команда, которая позволяет разделять прямые и непрямые зависимости пакетов.
// Так же удаляет все неиспользуемые зависимости в коде.
// Восстанавливает зависимости, которые используются в коде.


// 
// // WRITE IN TO FILE
// 

// Для записи в файл, его сначала нужно создать. Для этого импортируем встроенную
// библиотеку os и используем функцию Create(). Возвращает файл и ошибку.
// Обрабатываем ошибку с помощью if ... 
// Затем записываем в файл с помощью метода WriteString(), который принимает
// content. Возвращает длину байт и ошибку (len и err).
// Обрабатываем ошибку с помощью if ... 
// После того как записали в файл, его нужно закрыть. Для этого у file 
// есть метод Close(), который возвращает ошибку закрытия, если не получилось закрыть.
// В конце выводим сообщение о том, что "Запись успешна".
// Так же закрываем файл.
// Создали файл -> Проверили на ошибку -> Записали в файл -> Проверили на ошибку -> Закрыли файл.

files.go
///////
package files

import (
	"fmt"
	"os"
)

func ReadFile() {}

func WriteFile(content, name string) {
	file, err := os.Create(name)
	if err != nil {
		fmt.Println(err)
	}
	_, err = file.WriteString(content)
	if err != nil {
		file.Close()
		fmt.Println(err)
		return 
	}
	fmt.Println("Запись успешна")
	file.Close()
}
///////

main.go
///////
func main() {
	files.WriteFile("It is file", "file.txt")
	login := promptData("Введите логин: ")
	password := promptData("Введите пароль: ")
	url := promptData("Введите URL: ")
	myAccount, err := account.NewAccountWithTimestamp(login, password, url)
	if err != nil {
		fmt.Println("Неверный формат URL или Login")
		return
	}

	myAccount.OutputPassword()
	fmt.Println(myAccount)
}
///////


//
// // STACK FRAME
// 

// WriteFile (content, file, name, err)
// ^
// |
// Main

// Сначала в стэке вызывается Main
// Затем появляется frame WriteFile 
// Он выполняется и завершается
// Затем мы снова продолжаем frame Main
// А именно, то что было указано после WriteFile


//
// // DEFER
// 

// В go есть ключевое слово defer, которое позволяет отложить выполнение
// какого-либо действия на конец выполнения функции. Последняя операция 
// в стэке, после которой наш фрейм быдет уходить. Таких операций может быть 
// несколько.

files.go
///////
func WriteFile(content, name string) {
	file, err := os.Create(name)
	if err != nil {
		fmt.Println(err)
	}
	_, err = file.WriteString(content)
	defer file.Close()
	if err != nil {
		fmt.Println(err)
		return 
	}
	fmt.Println("Запись успешна")
}
///////

// defer работает таким образом, что тот, кого первого вызвали с defer,
// будет выполнен поледним.


// 
// // READ FROM FILE
// 

// Есть несколько способов читать файл:
// 1. Открыть файл и читать по байтам.
// file, err := os.Open("file.txt")
// Этот способ хорош, если файл большой и мы хотим 
// прочитать файл частями, не грузить сразу память.
// 2. Открыть и прочитать целиком файл.
// data, err := os.ReadFile("file.txt")

// Дальше нужно проверить на ошибку.
// После запуска программы, в консоли появятся байты.
// Чтобы увидить это в более читаемом формате, нужно преобразовать
// data к строке.

files.go
///////
package files

import (
	"fmt"
	"os"
)

func ReadFile() {
	data, err := os.ReadFile("file.txt")
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(string(data))
}

func WriteFile(content, name string) {
	file, err := os.Create(name)
	if err != nil {
		fmt.Println(err)
	}
	defer file.Close()
	_, err = file.WriteString(content)
	if err != nil {
		fmt.Println(err)
		return 
	}
	fmt.Println("Запись успешна")
}
///////


//
// // JSON
// 

// JSON - JavaScript Object Notation
// key: value
// "title": "iPhone 11"


// 
// // STRUCT TAGS
// 

// Структурные тэги - дополнительная мета-информация, которую мы можем
// добавить к нашей структуре. Для того, чтобы описать, как она будет представляться
// в JSON, XML или хранить совершенно любую мета-информацию.
// После указания типа, мы ставим обратные косые кавычки в которых записывается наш мета-тэг.
// `название:"значение тэга"`

account.go
///////
package account

import (
	"errors"
	"fmt"
	"math/rand/v2"
	"net/url"
	"reflect"
	"time"
)

var letterRunes = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-_!?*")

type Account struct {
	login string `json:"login" xml:"test"`
	password string
	url string
}

type AccountWithTimestamp struct{
	createdAt time.Time
	updatedAt time.Time
	Account
}

func (acc *Account) OutputPassword() {
	fmt.Println(acc.login, acc.password, acc.url)
}

func (acc *Account) generatePassword(n int) {
	result := make([]rune, n)
	for i := range result {
		result[i] = letterRunes[rand.IntN(len(letterRunes))]
	}
	acc.password = string(result)
}

func NewAccountWithTimestamp(login, password, urlString string) (*AccountWithTimestamp, error) {
	if login == "" {
		return nil, errors.New("INVALID_LOGIN")
	}
	// Validation
	_, err := url.ParseRequestURI(urlString)
	if err != nil {
		return nil, errors.New("INVALID_URL")
	}

	newAcc := &AccountWithTimestamp{
		createdAt: time.Now(),
		updatedAt: time.Now(),
		Account: Account{
			login: login,
			password: password,
			url: urlString,
		},
	}
	field, _ := reflect.TypeOf(newAcc).Elem().FieldByName("login")
	fmt.Println(string(field.Tag))
	if password == "" {
		newAcc.Account.generatePassword(12)
	}
	return newAcc, nil
}
///////

// Например, для json это будет поле login. А для xml это будет поле test.
// Благодаря этим тэгам, мы можем получать дополнительную информацию в рамках runtime.
// Для этого в go есть встроенная библиотека reflect. Reflect - встроенная библиотека,
// позволяющая работать с типами в runtime.

// login string `json:"login" xml:"test"`
// field, _ := reflect.TypeOf(newAcc).Elem().FieldByName("login")
// fmt.Println(string(field.Tag))


// 
// // SAVING JSON
// 

// Во внутреннем пакете json есть 2 метода Marshal и MarshalIndent, 
// которые обеспечивают преобразование.
// MarshalIndent - сохраняем в более читаемом виде, с отступами.
//
// Marshal - сохраняем в виде строки
// Принимает структуру, которую хотим превратить. 
// Возвращает массив байт file и ошибку error

// функция преобразования account

account.go
///////
func (acc *Account) ToBytes() ([]byte, error) {
	file, err := json.Marshal(acc)
	if err != nil {
		return nil, err
	}
	return file, nil
}
///////


// 
// // SLICE STRUCT
// 


vault.go
///////
package account

import (
	"encoding/json"
	"time"
)

type Vault struct {
	Accounts []Account `json:"accounts"`
	UpdatedAt time.Time `json:"updatedAt"`
}

func NewVault() *Vault {
	return &Vault{
		Accounts: []Account{},
		UpdatedAt: time.Now(),
	}
}

func (vault *Vault) AddAccount(acc Account) {
	vault.Accounts = append(vault.Accounts, acc)
	vault.UpdatedAt = time.Now()
}

func (vault *Vault) ToBytes() ([]byte, error) {
	file, err := json.Marshal(vault)
	if err != nil {
		return nil, err
	}
	return file, nil
}
///////