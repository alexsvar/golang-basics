// // GO THEORY 2 // //

// ARRAYS
// SLICES
// METHODS Cap & len
//
//
//
//
//
//
//
//


// 
// // ARRAYS & SLICES
// 

// Массив - последовательность однотипных данных, с фиксированной длиной.
// Каждому элементу массива присвоен свой индекс, начиная с 0.

// Способы объявления массивов:
// var arrayName [length]type
// var transactions [3]int
// transactions = [3]int{5, 10, -7}
// banks := [2]string{"Сбер", "Альфа"}

// Получение элемента по индексу:
fmt.Println(transactions[0])
// logs 5

// Запись элемента по индексу:
// banks[0] = "Сбер"
// fmt.Println(banks)
// logs ["Сбер" ]


// 
// // SLICES
// 

// Слайс (Срез) - срез массива без фиксированной длинны с указанием индексов начального
// и конечного элемента. 

// Объявление среза: 
partial := transactions[1:4]
// logs [2, 3, 4]
// 1 - индекс элемента, с которого будет начинаться срез.
// 4 - индекс элемента, до которого будет продолжаться срез, не включая сам этот элемент.
// Левая граница будет включена в срез, правая исключена.

partial2 := transactions[:4]
// Если не указан начальный индекс элемента, то срез будет состоять 
// из промежутка от начального до 4 индекса массива transactions, не включая сам элемент 4го индекса.

partial3 := transactions[1:]
// Если не указан конечный индекс элемента, то срез будет состоять 
// из промежутка от элемента индекса 1 до конца массива transactions, не включая сам элемент 4го индекса.

partial4 := transactions[:]
// Если не указаны начальный и конечный индексы массива transactions,
// то в переменную partial4 будет скопирован весь массив transactions.

func main() {
	transactions := [5]int{1, 2, 3, 4, 5}
	banks := [2]string{}

	fmt.Println(transactions[1])
	banks[0] = "Сбер"
	fmt.Println(banks)

	partial1 := transactions[1:4]
	// logs [2, 3, 4]

	partial2 := transactions[:4]
	// logs [1, 2, 3, 4]
}


// 
// // METHODS Cap & len
// 

func main() {
	transactions := [5]int{1, 2, 3, 4, 5}
	transactionsPartial := transactions[1:]
	transactionsPartial[0] = 30

	fmt.Println(transactions)
	fmt.Println(transactionsPartial)
}

// Если поменять элемент среза массива, в исходном массиве элемент так же поменяется,
// потому что срезы - ссылочные типы данных.
// Массивы занимают фиксированное месть в памяти, а срезы - ссылки на них.
// logs:
// [1 30 3 4 5]
// [30 3 4 5]

// // У срезов есть 2 свойства:
// cap - Capacity вместимость
//
// len - Length длина

// ARRAY ======== 520, 230, 320, 100
// SLICE OF ARRAY [1:] 230, 320, 100 - len 3, cap 3
// SLICE OF SLICE [:1] 230, ___, ___ - len 3, cap 1

fmt.Println(transactions) // logs [1 30 3 4 5]
fmt.Println(transactionsPartial) // logs [30 3 4 5]
fmt.Println(transactionsNewPartial) // logs [30]
fmt.Println(len(transactionsPartial), cap(transactionsPartial)) // logs 4 4
fmt.Println(len(transactionsNewPartial), cap(transactionsNewPartial)) // logs 1 4

